---
cover: ../.gitbook/assets/Group 7.png
coverY: 0
layout:
  cover:
    visible: true
    size: full
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# âŒ› Divide & Conquer

> In [computer science](https://en.wikipedia.org/wiki/Computer\_science), divide and conquer is an [algorithm design paradigm](https://en.wikipedia.org/wiki/Algorithm\_design\_paradigm). A divide-and-conquer [algorithm](https://en.wikipedia.org/wiki/Algorithm) [recursively](https://en.wikipedia.org/wiki/Recursion\_\(computer\_science\)) breaks down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem

> The divide-and-conquer technique is the basis of efficient algorithms for many problems, such as [sorting](https://en.wikipedia.org/wiki/Sorting\_algorithm) (e.g., [quicksort](https://en.wikipedia.org/wiki/Quicksort), [merge sort](https://en.wikipedia.org/wiki/Merge\_sort)), [multiplying large numbers](https://en.wikipedia.org/wiki/Multiplication\_algorithm) (e.g., the [Karatsuba algorithm](https://en.wikipedia.org/wiki/Karatsuba\_algorithm)), finding the [closest pair of points](https://en.wikipedia.org/wiki/Closest\_pair\_of\_points\_problem), [syntactic analysis](https://en.wikipedia.org/wiki/Syntactic\_analysis) (e.g., [top-down parsers](https://en.wikipedia.org/wiki/Top-down\_parser)), and computing the [discrete Fourier transform](https://en.wikipedia.org/wiki/Discrete\_Fourier\_transform) ([FFT](https://en.wikipedia.org/wiki/Fast\_Fourier\_transform)).[\[1\]](https://en.wikipedia.org/wiki/Divide-and-conquer\_algorithm#cite\_note-1)

> Designing efficient divide-and-conquer algorithms can be difficult. As in [mathematical induction](https://en.wikipedia.org/wiki/Mathematical\_induction), it is often necessary to generalize the problem to make it amenable to a recursive solution. The correctness of a divide-and-conquer algorithm is usually proved by mathematical induction, and its computational cost is often determined by solving [recurrence relations](https://en.wikipedia.org/wiki/Recurrence\_relation).

{% hint style="info" %}
#### Learning Material (understanding classic instances of Divide & Conquer)

* [**UCB CS170 \[1\] Introduction, Big-O Notation, Arithmetic**](https://www.bilibili.com/video/BV1BU4y1b7RK?p=1) (introduces **Karatsuba** & $$O(n\log n)$$ **Multiplication**)
* [**UCB CS170 \[2\] Divide-and-Conquer (Part 1)**](https://www.bilibili.com/video/BV1BU4y1b7RK?p=2)
* [**UCB CS170 \[3\] Divide-and-Conquer (Part 2)**](https://www.bilibili.com/video/BV1BU4y1b7RK?p=3\&vd\_source=9621e539f648f22172899af8f4fc2ab7)
{% endhint %}

## Practices

* [ ] [**VFMUL - Very Fast Multiplication**](https://www.spoj.com/problems/VFMUL/) (implement via **Karatsuba**)
* [ ] Median-Finding
* [ ] Merge Sort
* [ ] Quick Sort
* [ ] Convex Hull ([**Divide-and-Conquer**](https://web.ntnu.edu.tw/\~algo/ConvexHull.html) method)

## Graduation Challenge

* [ ] Median-Finding
